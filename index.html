<!DOCTYPE HTML>
<html><head><meta charset="UTF-8"><title>Atsumari</title><script type="text/javascript" src="elm-runtime.js"></script><script type="text/javascript">Elm.Atsumari = Elm.Atsumari || {};
Elm.Atsumari.make = function (_elm) {
   "use strict";
   _elm.Atsumari = _elm.Atsumari || {};
   if (_elm.Atsumari.values)
   return _elm.Atsumari.values;
   var _N = Elm.Native,
   _U = _N.Utils.make(_elm),
   _L = _N.List.make(_elm),
   _E = _N.Error.make(_elm),
   _J = _N.JavaScript.make(_elm),
   $moduleName = "Atsumari";
   var Basics = Elm.Basics.make(_elm);
   var Color = Elm.Color.make(_elm);
   var Dict = Elm.Dict.make(_elm);
   var Graphics = Graphics || {};
   Graphics.Collage = Elm.Graphics.Collage.make(_elm);
   var Graphics = Graphics || {};
   Graphics.Element = Elm.Graphics.Element.make(_elm);
   var HexGrid = Elm.HexGrid.make(_elm);
   var List = Elm.List.make(_elm);
   var Maybe = Elm.Maybe.make(_elm);
   var Mouse = Elm.Mouse.make(_elm);
   var Native = Native || {};
   Native.Ports = Elm.Native.Ports.make(_elm);
   var Set = Elm.Set.make(_elm);
   var Signal = Elm.Signal.make(_elm);
   var String = Elm.String.make(_elm);
   var Text = Elm.Text.make(_elm);
   var Time = Elm.Time.make(_elm);
   var Window = Elm.Window.make(_elm);
   var _op = {};
   var mousePos = A2(Signal._op["~"],
   A2(Signal._op["<~"],
   F2(function (_v0,_v1) {
      return function () {
         switch (_v1.ctor)
         {case "_Tuple2":
            return function () {
                 switch (_v0.ctor)
                 {case "_Tuple2":
                    return {ctor: "_Tuple2"
                           ,_0: _v1._0 - (_v0._0 / 2 | 0)
                           ,_1: _v1._1 - (_v0._1 / 2 | 0)};}
                 _E.Case($moduleName,
                 "on line 50, column 32 to 64");
              }();}
         _E.Case($moduleName,
         "on line 50, column 32 to 64");
      }();
   }),
   Window.dimensions),
   Mouse.position);
   var hexSize = A2(Signal._op["<~"],
   function (h) {
      return 2 * Basics.toFloat(h) / (3 * Basics.toFloat(7) + 1);
   },
   Window.height);
   var hovered = A2(Signal._op["~"],
   A2(Signal._op["<~"],
   F2(function (hexSize,pos) {
      return A2(HexGrid.pixelToHexCoord,
      hexSize,
      pos);
   }),
   hexSize),
   mousePos);
   var lastClicked = A2(Signal.sampleOn,
   Mouse.clicks,
   hovered);
   var frames = Time.fps(30);
   var overlayStyler = F2(function (cell,
   s) {
      return cell ? Graphics.Collage.rotate(30)(Graphics.Collage.filled(Color.black)(Graphics.Collage.ngon(6)(s))) : Graphics.Collage.toForm(Graphics.Element.empty);
   });
   var text = function ($) {
      return Text.centered(Text.bold(Text.height(25)(Text.toText($))));
   };
   var Numbered = function (a) {
      return {ctor: "Numbered"
             ,_0: a};
   };
   var Anchor = {ctor: "Anchor"};
   var Filled = {ctor: "Filled"};
   var orphaned = F2(function (coord,
   grid) {
      return function () {
         var neighbors = List.map(function (c) {
            return {ctor: "_Tuple2"
                   ,_0: c
                   ,_1: A2(HexGrid.valueAt,
                   c,
                   grid)};
         })(HexGrid.neighbors(coord));
         return !_U.eq(A2(HexGrid.valueAt,
         coord,
         grid),
         Maybe.Just(Filled)) ? false : A2(List.any,
         function (v) {
            return _U.eq(v,
            Maybe.Just(Filled)) || _U.eq(v,
            Maybe.Just(Anchor));
         },
         A2(List.map,
         Basics.snd,
         neighbors)) ? false : true;
      }();
   });
   var surrounded = F2(function (coord,
   grid) {
      return function () {
         var neighbors = List.map(Basics.flip(HexGrid.valueAt)(grid))(HexGrid.neighbors(coord));
         return A2(List.all,
         function (v) {
            return _U.eq(v,
            Maybe.Just(Filled)) || _U.eq(v,
            Maybe.Just(Anchor));
         },
         neighbors) ? true : false;
      }();
   });
   var Empty = {ctor: "Empty"};
   var hammerhead = HexGrid.remove({ctor: "_Tuple2"
                                   ,_0: -1
                                   ,_1: 2})(HexGrid.remove({ctor: "_Tuple2"
                                                           ,_0: 0
                                                           ,_1: 0})(HexGrid.remove({ctor: "_Tuple2"
                                                                                   ,_0: 1
                                                                                   ,_1: -2})(A2(HexGrid.insertIfPossible,
   {ctor: "_Tuple2",_0: -1,_1: -3},
   Anchor)(A2(HexGrid.insertIfPossible,
   {ctor: "_Tuple2",_0: -2,_1: 3},
   Numbered(3))(A2(HexGrid.insertIfPossible,
   {ctor: "_Tuple2",_0: -4,_1: 3},
   Numbered(4))(A2(HexGrid.insertIfPossible,
   {ctor: "_Tuple2",_0: -2,_1: 0},
   Numbered(3))(A2(HexGrid.insertIfPossible,
   {ctor: "_Tuple2",_0: 0,_1: -1},
   Numbered(3))(A2(HexGrid.insertIfPossible,
   {ctor: "_Tuple2",_0: -2,_1: -3},
   Numbered(1))(A2(HexGrid.rectangularHexGrid,
   {ctor: "_Tuple2",_0: 4,_1: 7},
   Empty))))))))));
   var hammerheadWin = HexGrid.Rectangular({ctor: "_Tuple2"
                                           ,_0: 4
                                           ,_1: 7})(Dict.fromList(_J.toList([{ctor: "_Tuple2"
                                                                             ,_0: {ctor: "_Tuple2"
                                                                                  ,_0: -5
                                                                                  ,_1: 3}
                                                                             ,_1: Empty}
                                                                            ,{ctor: "_Tuple2"
                                                                             ,_0: {ctor: "_Tuple2"
                                                                                  ,_0: -4
                                                                                  ,_1: 1}
                                                                             ,_1: Empty}
                                                                            ,{ctor: "_Tuple2"
                                                                             ,_0: {ctor: "_Tuple2"
                                                                                  ,_0: -4
                                                                                  ,_1: 2}
                                                                             ,_1: Empty}
                                                                            ,{ctor: "_Tuple2"
                                                                             ,_0: {ctor: "_Tuple2"
                                                                                  ,_0: -4
                                                                                  ,_1: 3}
                                                                             ,_1: Numbered(4)}
                                                                            ,{ctor: "_Tuple2"
                                                                             ,_0: {ctor: "_Tuple2"
                                                                                  ,_0: -3
                                                                                  ,_1: -1}
                                                                             ,_1: Empty}
                                                                            ,{ctor: "_Tuple2"
                                                                             ,_0: {ctor: "_Tuple2"
                                                                                  ,_0: -3
                                                                                  ,_1: 0}
                                                                             ,_1: Filled}
                                                                            ,{ctor: "_Tuple2"
                                                                             ,_0: {ctor: "_Tuple2"
                                                                                  ,_0: -3
                                                                                  ,_1: 1}
                                                                             ,_1: Filled}
                                                                            ,{ctor: "_Tuple2"
                                                                             ,_0: {ctor: "_Tuple2"
                                                                                  ,_0: -3
                                                                                  ,_1: 2}
                                                                             ,_1: Filled}
                                                                            ,{ctor: "_Tuple2"
                                                                             ,_0: {ctor: "_Tuple2"
                                                                                  ,_0: -3
                                                                                  ,_1: 3}
                                                                             ,_1: Filled}
                                                                            ,{ctor: "_Tuple2"
                                                                             ,_0: {ctor: "_Tuple2"
                                                                                  ,_0: -2
                                                                                  ,_1: -3}
                                                                             ,_1: Numbered(1)}
                                                                            ,{ctor: "_Tuple2"
                                                                             ,_0: {ctor: "_Tuple2"
                                                                                  ,_0: -2
                                                                                  ,_1: -2}
                                                                             ,_1: Filled}
                                                                            ,{ctor: "_Tuple2"
                                                                             ,_0: {ctor: "_Tuple2"
                                                                                  ,_0: -2
                                                                                  ,_1: -1}
                                                                             ,_1: Empty}
                                                                            ,{ctor: "_Tuple2"
                                                                             ,_0: {ctor: "_Tuple2"
                                                                                  ,_0: -2
                                                                                  ,_1: 0}
                                                                             ,_1: Numbered(3)}
                                                                            ,{ctor: "_Tuple2"
                                                                             ,_0: {ctor: "_Tuple2"
                                                                                  ,_0: -2
                                                                                  ,_1: 1}
                                                                             ,_1: Filled}
                                                                            ,{ctor: "_Tuple2"
                                                                             ,_0: {ctor: "_Tuple2"
                                                                                  ,_0: -2
                                                                                  ,_1: 2}
                                                                             ,_1: Empty}
                                                                            ,{ctor: "_Tuple2"
                                                                             ,_0: {ctor: "_Tuple2"
                                                                                  ,_0: -2
                                                                                  ,_1: 3}
                                                                             ,_1: Numbered(3)}
                                                                            ,{ctor: "_Tuple2"
                                                                             ,_0: {ctor: "_Tuple2"
                                                                                  ,_0: -1
                                                                                  ,_1: -3}
                                                                             ,_1: Anchor}
                                                                            ,{ctor: "_Tuple2"
                                                                             ,_0: {ctor: "_Tuple2"
                                                                                  ,_0: -1
                                                                                  ,_1: -2}
                                                                             ,_1: Filled}
                                                                            ,{ctor: "_Tuple2"
                                                                             ,_0: {ctor: "_Tuple2"
                                                                                  ,_0: -1
                                                                                  ,_1: -1}
                                                                             ,_1: Filled}
                                                                            ,{ctor: "_Tuple2"
                                                                             ,_0: {ctor: "_Tuple2"
                                                                                  ,_0: -1
                                                                                  ,_1: 0}
                                                                             ,_1: Filled}
                                                                            ,{ctor: "_Tuple2"
                                                                             ,_0: {ctor: "_Tuple2"
                                                                                  ,_0: -1
                                                                                  ,_1: 1}
                                                                             ,_1: Empty}
                                                                            ,{ctor: "_Tuple2"
                                                                             ,_0: {ctor: "_Tuple2"
                                                                                  ,_0: 0
                                                                                  ,_1: -3}
                                                                             ,_1: Filled}
                                                                            ,{ctor: "_Tuple2"
                                                                             ,_0: {ctor: "_Tuple2"
                                                                                  ,_0: 0
                                                                                  ,_1: -2}
                                                                             ,_1: Empty}
                                                                            ,{ctor: "_Tuple2"
                                                                             ,_0: {ctor: "_Tuple2"
                                                                                  ,_0: 0
                                                                                  ,_1: -1}
                                                                             ,_1: Numbered(3)}
                                                                            ,{ctor: "_Tuple2"
                                                                             ,_0: {ctor: "_Tuple2"
                                                                                  ,_0: 1
                                                                                  ,_1: -3}
                                                                             ,_1: Empty}])));
   var styler = F2(function (cell,
   s) {
      return function () {
         switch (cell.ctor)
         {case "Anchor":
            return Graphics.Collage.scale(0.6)(Graphics.Collage.rotate(30)(Graphics.Collage.filled(Color.purple)(Graphics.Collage.circle(s))));
            case "Empty":
            return Graphics.Collage.scale(0.8)(Graphics.Collage.rotate(30)(Graphics.Collage.filled(Color.green)(Graphics.Collage.ngon(6)(s))));
            case "Filled":
            return Graphics.Collage.scale(0.8)(Graphics.Collage.rotate(30)(Graphics.Collage.filled(Color.purple)(Graphics.Collage.ngon(6)(s))));
            case "Numbered":
            return Graphics.Collage.group(_J.toList([Graphics.Collage.scale(0.8)(Graphics.Collage.rotate(30)(Graphics.Collage.filled(Color.green)(Graphics.Collage.ngon(6)(s))))
                                                    ,Graphics.Collage.toForm(text(String.show(cell._0)))]));}
         _E.Case($moduleName,
         "between lines 37 and 41");
      }();
   });
   var scene = F3(function (_v10,
   hexSize,
   grid) {
      return function () {
         switch (_v10.ctor)
         {case "_Tuple2":
            return function () {
                 var won = A2(HexGrid.gridEqual,
                 grid,
                 hammerheadWin);
                 var wonText = won ? Text.centered(Text.bold(Text.height(50)(Text.toText("you win!")))) : Graphics.Element.empty;
                 return Graphics.Element.layers(_J.toList([A3(Graphics.Element.container,
                                                          _v10._0,
                                                          _v10._1,
                                                          Graphics.Element.middle)(A3(HexGrid.showHexGrid,
                                                          hexSize,
                                                          styler,
                                                          grid))
                                                          ,A4(Graphics.Element.container,
                                                          _v10._0,
                                                          _v10._1,
                                                          Graphics.Element.middle,
                                                          wonText)]));
              }();}
         _E.Case($moduleName,
         "between lines 117 and 121");
      }();
   });
   var contiguousBlock = F2(function (coord,
   grid) {
      return function () {
         var _v14 = A2(HexGrid.valueAt,
         coord,
         grid);
         switch (_v14.ctor)
         {case "Just":
            switch (_v14._0.ctor)
              {case "Empty":
                 return _J.toList([]);
                 case "Numbered":
                 return _J.toList([]);}
              break;
            case "Nothing":
            return _J.toList([]);}
         return function () {
            var inner = F3(function (coord$,
            grid$,
            coords) {
               return function () {
                  var neighbors = List.filter(function (c) {
                     return _U.eq(A2(HexGrid.valueAt,
                     c,
                     grid$),
                     Maybe.Just(Filled)) || _U.eq(A2(HexGrid.valueAt,
                     c,
                     grid$),
                     Maybe.Just(Anchor));
                  })(HexGrid.neighbors(coord$));
                  var coords$ = A3(List.foldl,
                  Set.insert,
                  coords,
                  neighbors);
                  return _U.eq(coords,
                  coords$) ? coords : A3(List.foldl,
                  F2(function (c,cs) {
                     return A3(inner,c,grid$,cs);
                  }),
                  coords$,
                  neighbors);
               }();
            });
            var coords = Set.toList(A2(inner,
            coord,
            grid)(Set.fromList(_J.toList([coord]))));
            var values = Maybe.justs(List.map(function (c) {
               return A3(Basics.id,
               HexGrid.valueAt,
               c,
               grid);
            })(coords));
            return A2(List.zip,
            coords,
            values);
         }();
      }();
   });
   var anchored = F2(function (coord,
   grid) {
      return function () {
         var block = List.map(Basics.snd)(A2(contiguousBlock,
         coord,
         grid));
         return A2(List.any,
         function (x) {
            return _U.eq(x,Anchor);
         },
         block);
      }();
   });
   var valid = F2(function (coord,
   grid) {
      return function () {
         var neighbors = List.filter(function (c) {
            return _U.eq(A2(HexGrid.valueAt,
            c,
            grid),
            Maybe.Just(Filled));
         })(HexGrid.neighbors(coord));
         var grid$ = function () {
            var _v17 = A2(HexGrid.valueAt,
            coord,
            grid);
            switch (_v17.ctor)
            {case "Just":
               switch (_v17._0.ctor)
                 {case "Empty":
                    return A3(HexGrid.insertIfPossible,
                      coord,
                      Filled,
                      grid);
                    case "Filled":
                    return A3(HexGrid.insertIfPossible,
                      coord,
                      Empty,
                      grid);}
                 break;}
            return grid;
         }();
         return A2(orphaned,
         coord,
         grid$) ? false : A2(surrounded,
         coord,
         grid) ? false : A2(List.any,
         function (c) {
            return A2(orphaned,c,grid$);
         },
         neighbors) ? false : A2(List.any,
         function (c) {
            return A2(surrounded,
            c,
            grid$);
         },
         neighbors) ? false : A2(List.any,
         function (c) {
            return Basics.not(anchored(c)(grid$));
         },
         neighbors) ? false : true;
      }();
   });
   var step = F2(function (coord,
   grid) {
      return Basics.not(A2(valid,
      coord,
      grid)) ? grid : function () {
         var _v19 = A2(HexGrid.valueAt,
         coord,
         grid);
         switch (_v19.ctor)
         {case "Just":
            switch (_v19._0.ctor)
              {case "Empty":
                 return A3(HexGrid.insertIfPossible,
                   coord,
                   Filled,
                   grid);
                 case "Filled":
                 return A3(HexGrid.insertIfPossible,
                   coord,
                   Empty,
                   grid);}
              break;}
         return grid;
      }();
   });
   var grid = A3(Signal.foldp,
   step,
   hammerhead,
   lastClicked);
   var main = A2(Signal._op["~"],
   A2(Signal._op["~"],
   A2(Signal._op["<~"],
   scene,
   Window.dimensions),
   hexSize),
   grid);
   _elm.Atsumari.values = {_op: _op
                          ,hammerhead: hammerhead
                          ,hammerheadWin: hammerheadWin
                          ,styler: styler
                          ,text: text
                          ,overlayStyler: overlayStyler
                          ,frames: frames
                          ,hexSize: hexSize
                          ,mousePos: mousePos
                          ,hovered: hovered
                          ,lastClicked: lastClicked
                          ,contiguousBlock: contiguousBlock
                          ,anchored: anchored
                          ,orphaned: orphaned
                          ,surrounded: surrounded
                          ,valid: valid
                          ,step: step
                          ,grid: grid
                          ,scene: scene
                          ,main: main
                          ,Empty: Empty
                          ,Filled: Filled
                          ,Anchor: Anchor
                          ,Numbered: Numbered};
   return _elm.Atsumari.values;
};Elm.HexGrid = Elm.HexGrid || {};
Elm.HexGrid.make = function (_elm) {
   "use strict";
   _elm.HexGrid = _elm.HexGrid || {};
   if (_elm.HexGrid.values)
   return _elm.HexGrid.values;
   var _N = Elm.Native,
   _U = _N.Utils.make(_elm),
   _L = _N.List.make(_elm),
   _E = _N.Error.make(_elm),
   _J = _N.JavaScript.make(_elm),
   $moduleName = "HexGrid";
   var Basics = Elm.Basics.make(_elm);
   var Color = Elm.Color.make(_elm);
   var Dict = Elm.Dict.make(_elm);
   var Graphics = Graphics || {};
   Graphics.Collage = Elm.Graphics.Collage.make(_elm);
   var Graphics = Graphics || {};
   Graphics.Element = Elm.Graphics.Element.make(_elm);
   var List = Elm.List.make(_elm);
   var Maybe = Elm.Maybe.make(_elm);
   var Native = Native || {};
   Native.Ports = Elm.Native.Ports.make(_elm);
   var Set = Elm.Set.make(_elm);
   var Signal = Elm.Signal.make(_elm);
   var String = Elm.String.make(_elm);
   var Text = Elm.Text.make(_elm);
   var Time = Elm.Time.make(_elm);
   var _op = {};
   var hexRound = function (_v0) {
      return function () {
         switch (_v0.ctor)
         {case "_Tuple2":
            return function () {
                 var z = 0 - _v0._0 - _v0._1;
                 var $ = {ctor: "_Tuple3"
                         ,_0: Basics.round(_v0._0)
                         ,_1: Basics.round(_v0._1)
                         ,_2: Basics.round(z)},
                 rx = $._0,
                 ry = $._1,
                 rz = $._2;
                 var errX = Basics.abs(rx - _v0._0);
                 var errY = Basics.abs(ry - _v0._1);
                 var errZ = Basics.abs(rz - z);
                 return _U.cmp(errX,
                 errY) > 0 && _U.cmp(errX,
                 errZ) > 0 ? {ctor: "_Tuple2"
                             ,_0: 0 - ry - rz
                             ,_1: ry} : _U.cmp(errY,
                 errZ) > 0 ? {ctor: "_Tuple2"
                             ,_0: rx
                             ,_1: 0 - rx - rz} : {ctor: "_Tuple2"
                                                 ,_0: rx
                                                 ,_1: ry};
              }();}
         _E.Case($moduleName,
         "between lines 184 and 191");
      }();
   };
   var hexAdd = F2(function (_v4,
   _v5) {
      return function () {
         switch (_v5.ctor)
         {case "_Tuple2":
            return function () {
                 switch (_v4.ctor)
                 {case "_Tuple2":
                    return {ctor: "_Tuple2"
                           ,_0: _v4._0 + _v5._0
                           ,_1: _v4._1 + _v5._1};}
                 _E.Case($moduleName,
                 "on line 139, column 29 to 45");
              }();}
         _E.Case($moduleName,
         "on line 139, column 29 to 45");
      }();
   });
   var hexMult = F2(function (_v12,
   n) {
      return function () {
         switch (_v12.ctor)
         {case "_Tuple2":
            return {ctor: "_Tuple2"
                   ,_0: Basics.toFloat(_v12._0) * n
                   ,_1: Basics.toFloat(_v12._1) * n};}
         _E.Case($moduleName,
         "on line 136, column 21 to 49");
      }();
   });
   var axialToCube = function (_v16) {
      return function () {
         switch (_v16.ctor)
         {case "_Tuple2":
            return {ctor: "_Tuple3"
                   ,_0: _v16._0
                   ,_1: _v16._1
                   ,_2: 0 - _v16._0 - _v16._1};}
         _E.Case($moduleName,
         "on line 126, column 23 to 35");
      }();
   };
   var distance = F2(function (coord1,
   coord2) {
      return function () {
         var $ = axialToCube(coord2),
         x2 = $._0,
         y2 = $._1,
         z2 = $._2;
         var $ = axialToCube(coord1),
         x1 = $._0,
         y1 = $._1,
         z1 = $._2;
         return (Basics.abs(x1 - x2) + Basics.abs(y1 - y2) + Basics.abs(z1 - z2)) / 2 | 0;
      }();
   });
   var line = F2(function (coord1,
   coord2) {
      return _U.eq(coord1,
      coord2) ? _J.toList([]) : function () {
         var n = Basics.toFloat(A2(distance,
         coord1,
         coord2));
         var pts = _L.range(0,n);
         return A2(List.map,
         function (i) {
            return hexRound(A2(hexAdd,
            A2(hexMult,coord1,1 - i / n),
            A2(hexMult,coord2,i / n)));
         },
         pts);
      }();
   });
   var SOutlined = function (a) {
      return {ctor: "SOutlined"
             ,_0: a};
   };
   var SGradient = function (a) {
      return {ctor: "SGradient"
             ,_0: a};
   };
   var STextured = function (a) {
      return {ctor: "STextured"
             ,_0: a};
   };
   var SColor = function (a) {
      return {ctor: "SColor"
             ,_0: a};
   };
   var hexCoord = F2(function (x,
   y) {
      return {ctor: "_Tuple2"
             ,_0: x
             ,_1: y};
   });
   var pixelToHexCoord = F2(function (s,
   _v20) {
      return function () {
         switch (_v20.ctor)
         {case "_Tuple2":
            return function () {
                 var y$ = Basics.toFloat(_v20._1) / s;
                 var x$ = Basics.toFloat(_v20._0) / (Basics.sqrt(3) * s);
                 var r = Basics.floor(Basics.toFloat(Basics.floor(y$ - x$ + 1) + Basics.floor(y$ + x$ + 1)) / 3);
                 var q = Basics.floor(Basics.toFloat(Basics.floor(2 * x$ + 1) - r) / 2);
                 return A2(hexCoord,q,r);
              }();}
         _E.Case($moduleName,
         "between lines 78 and 82");
      }();
   });
   var neighbors = function (_v24) {
      return function () {
         switch (_v24.ctor)
         {case "_Tuple2":
            return _J.toList([A2(hexCoord,
                             _v24._0 + 1,
                             _v24._1)
                             ,A2(hexCoord,
                             _v24._0 + 1,
                             _v24._1 - 1)
                             ,A2(hexCoord,
                             _v24._0,
                             _v24._1 - 1)
                             ,A2(hexCoord,
                             _v24._0 - 1,
                             _v24._1)
                             ,A2(hexCoord,
                             _v24._0 - 1,
                             _v24._1 + 1)
                             ,A2(hexCoord,
                             _v24._0,
                             _v24._1 + 1)]);}
         _E.Case($moduleName,
         "between lines 110 and 111");
      }();
   };
   var diagonals = function (_v28) {
      return function () {
         switch (_v28.ctor)
         {case "_Tuple2":
            return _J.toList([A2(hexCoord,
                             _v28._0 + 2,
                             _v28._1 - 1)
                             ,A2(hexCoord,
                             _v28._0 + 1,
                             _v28._1 - 2)
                             ,A2(hexCoord,
                             _v28._0 - 1,
                             _v28._1 - 1)
                             ,A2(hexCoord,
                             _v28._0 - 2,
                             _v28._1 + 1)
                             ,A2(hexCoord,
                             _v28._0 - 1,
                             _v28._1 + 2)
                             ,A2(hexCoord,
                             _v28._0 + 1,
                             _v28._1 + 1)]);}
         _E.Case($moduleName,
         "between lines 115 and 116");
      }();
   };
   var range = F2(function (_v32,
   n) {
      return function () {
         switch (_v32.ctor)
         {case "_Tuple2":
            return A2(List.concatMap,
              function (dx) {
                 return A2(List.map,
                 function (dy) {
                    return A2(hexCoord,
                    _v32._0 + dx,
                    _v32._1 + dy);
                 },
                 _L.range(A2(Basics.max,
                 0 - n,
                 0 - dx - n),
                 A2(Basics.min,n,0 - dx + n)));
              },
              _L.range(0 - n,n));}
         _E.Case($moduleName,
         "between lines 144 and 148");
      }();
   });
   var neighbor = F2(function (_v36,
   direction) {
      return function () {
         switch (_v36.ctor)
         {case "_Tuple2":
            return function () {
                 var $ = function () {
                    switch (direction)
                    {case 0: return {ctor: "_Tuple2"
                                    ,_0: 1
                                    ,_1: 0};
                       case 1: return {ctor: "_Tuple2"
                                      ,_0: 1
                                      ,_1: -1};
                       case 2: return {ctor: "_Tuple2"
                                      ,_0: 0
                                      ,_1: -1};
                       case 3: return {ctor: "_Tuple2"
                                      ,_0: -1
                                      ,_1: 0};
                       case 4: return {ctor: "_Tuple2"
                                      ,_0: -1
                                      ,_1: 1};
                       case 5: return {ctor: "_Tuple2"
                                      ,_0: 0
                                      ,_1: 1};}
                    return {ctor: "_Tuple2"
                           ,_0: 0
                           ,_1: 0};
                 }(),
                 dx = $._0,
                 dy = $._1;
                 return A2(hexCoord,
                 _v36._0 + dx,
                 _v36._1 + dy);
              }();}
         _E.Case($moduleName,
         "between lines 172 and 180");
      }();
   });
   var ring = F2(function (_v41,
   r) {
      return function () {
         switch (_v41.ctor)
         {case "_Tuple2":
            return function () {
                 var h = A2(hexCoord,
                 _v41._0 - r,
                 _v41._1 + r);
                 return _U.cmp(r,
                 0) < 0 ? _J.toList([]) : A3(List.scanl,
                 F2(function (i,h$) {
                    return A2(neighbor,h$,i);
                 }),
                 h,
                 A2(List.concatMap,
                 function (j) {
                    return A2(List.repeat,r,j);
                 },
                 _L.range(0,5)));
              }();}
         _E.Case($moduleName,
         "between lines 160 and 166");
      }();
   });
   var Right = {ctor: "Right"};
   var Left = {ctor: "Left"};
   var rotation = F2(function (direction,
   coord) {
      return function () {
         var $ = axialToCube(coord),
         x = $._0,
         y = $._1,
         z = $._2;
         return function () {
            switch (direction.ctor)
            {case "Left":
               return A2(hexCoord,0 - z,0 - x);
               case "Right":
               return A2(hexCoord,
                 0 - y,
                 0 - z);}
            _E.Case($moduleName,
            "between lines 153 and 157");
         }();
      }();
   });
   var Hexagonal = F2(function (a,
   b) {
      return {ctor: "Hexagonal"
             ,_0: a
             ,_1: b};
   });
   var hexagonalHexGrid = F2(function (r,
   a) {
      return function () {
         var row = function (y) {
            return A2(List.map,
            function (n) {
               return {ctor: "_Tuple2"
                      ,_0: {ctor: "_Tuple2"
                           ,_0: n - A2(Basics.min,y,r)
                           ,_1: y - r}
                      ,_1: a};
            },
            _L.range(0,
            r * 2 - Basics.abs(r - y)));
         };
         return Hexagonal(r)(Dict.fromList(A2(List.concatMap,
         function (n) {
            return row(n);
         },
         _L.range(0,2 * r))));
      }();
   });
   var Rectangular = F2(function (a,
   b) {
      return {ctor: "Rectangular"
             ,_0: a
             ,_1: b};
   });
   var rectangularHexGrid = F2(function (s,
   a) {
      return function () {
         var h = Basics.snd(s);
         var off = Basics.ceiling(Basics.toFloat(h / 2 | 0) / 2);
         var w = Basics.fst(s);
         var row = F2(function (x,y) {
            return A2(List.map,
            function (n) {
               return {ctor: "_Tuple2"
                      ,_0: A2(hexCoord,n,y)
                      ,_1: a};
            },
            _L.range(0 - x,w - 1 - x));
         });
         var rowPair = function (offset) {
            return _L.append(A2(row,
            offset,
            offset * 2),
            A2(row,offset,offset * 2 + 1));
         };
         var hexes = A2(List.concatMap,
         function (n) {
            return rowPair(n);
         },
         _L.range(0,
         Basics.ceiling(Basics.toFloat(h) / 2) - 1));
         var hexes$ = A2(List.filter,
         function (_v46) {
            return function () {
               switch (_v46.ctor)
               {case "_Tuple2":
                  switch (_v46._0.ctor)
                    {case "_Tuple2":
                       return _U.cmp(_v46._0._1,
                         h) < 0;}
                    break;}
               _E.Case($moduleName,
               "on line 43, column 42 to 47");
            }();
         },
         hexes);
         return Rectangular({ctor: "_Tuple2"
                            ,_0: w
                            ,_1: h})(Dict.fromList(A2(List.map,
         function (_v52) {
            return function () {
               switch (_v52.ctor)
               {case "_Tuple2":
                  switch (_v52._0.ctor)
                    {case "_Tuple2":
                       return {ctor: "_Tuple2"
                              ,_0: {ctor: "_Tuple2"
                                   ,_0: _v52._0._0 - off
                                   ,_1: _v52._0._1 - (h / 2 | 0)}
                              ,_1: _v52._1};}
                    break;}
               _E.Case($moduleName,
               "on line 45, column 69 to 98");
            }();
         },
         hexes$)));
      }();
   });
   var showHexGrid = F3(function (r,
   former,
   grid) {
      return function () {
         switch (grid.ctor)
         {case "Hexagonal":
            return function () {
                 var h = Basics.round(r * Basics.toFloat(grid._0 * 2 + 1) * 2.5 + r);
                 var w = function () {
                    var w$ = Basics.round(Basics.sqrt(3) / 2 * r);
                    return 2 * (w$ + (grid._0 * 2 + 1) * w$);
                 }();
                 var position = F2(function (_v65,
                 r) {
                    return function () {
                       switch (_v65.ctor)
                       {case "_Tuple2":
                          return Graphics.Collage.move({ctor: "_Tuple2"
                                                       ,_0: Basics.sqrt(3) * r * Basics.toFloat(_v65._0) + Basics.sqrt(3) / 2 * r * Basics.toFloat(_v65._1)
                                                       ,_1: -1.5 * r * Basics.toFloat(_v65._1)});}
                       _E.Case($moduleName,
                       "on line 66, column 58 to 151");
                    }();
                 });
                 var drawHex = F2(function (_v69,
                 r) {
                    return function () {
                       switch (_v69.ctor)
                       {case "_Tuple2":
                          return A2(position,
                            _v69._0,
                            r)(former(_v69._1)(r));}
                       _E.Case($moduleName,
                       "on line 67, column 61 to 93");
                    }();
                 });
                 var hexes = Graphics.Collage.group(A2(List.map,
                 function (hex) {
                    return A2(drawHex,hex,r);
                 },
                 Dict.toList(grid._1)));
                 return A3(Graphics.Collage.collage,
                 w,
                 h,
                 _J.toList([hexes]));
              }();
            case "Rectangular":
            switch (grid._0.ctor)
              {case "_Tuple2":
                 return function () {
                      var h$ = Basics.round(r * Basics.toFloat(grid._0._1 * 2 + 1) * 2.5 + r);
                      var w$ = function () {
                         var w$$ = Basics.round(Basics.sqrt(3) / 2 * r);
                         return 2 * (w$$ + (grid._0._0 * 2 + 1) * w$$);
                      }();
                      var position = F2(function (_v73,
                      r) {
                         return function () {
                            switch (_v73.ctor)
                            {case "_Tuple2":
                               return Graphics.Collage.move({ctor: "_Tuple2"
                                                            ,_0: Basics.sqrt(3) * r * Basics.toFloat(_v73._0) + Basics.sqrt(3) / 2 * r * Basics.toFloat(_v73._1)
                                                            ,_1: -1.5 * r * Basics.toFloat(_v73._1)});}
                            _E.Case($moduleName,
                            "on line 59, column 58 to 151");
                         }();
                      });
                      var drawHex = F2(function (_v77,
                      r) {
                         return function () {
                            switch (_v77.ctor)
                            {case "_Tuple2":
                               return A2(position,
                                 _v77._0,
                                 r)(former(_v77._1)(r));}
                            _E.Case($moduleName,
                            "on line 60, column 61 to 93");
                         }();
                      });
                      var hexes = Graphics.Collage.group(A2(List.map,
                      function (hex) {
                         return A2(drawHex,hex,r);
                      },
                      Dict.toList(grid._1)));
                      return A3(Graphics.Collage.collage,
                      w$,
                      h$,
                      _J.toList([hexes]));
                   }();}
              break;}
         _E.Case($moduleName,
         "between lines 57 and 75");
      }();
   });
   var inGrid = F2(function (_v81,
   grid) {
      return function () {
         switch (_v81.ctor)
         {case "_Tuple2":
            return function () {
                 switch (grid.ctor)
                 {case "Hexagonal":
                    return function () {
                         var offset = grid._0 * 2 - Basics.abs(_v81._1);
                         return _U.cmp(_v81._1,
                         0 - grid._0) < 0 ? false : _U.cmp(_v81._1,
                         grid._0) > 0 ? false : _U.cmp(_v81._0 + grid._0 + A2(Basics.min,
                         0,
                         _v81._1),
                         0) < 0 ? false : _U.cmp(_v81._0,
                         offset - grid._0 - A2(Basics.min,
                         0,
                         _v81._1)) > 0 ? false : true;
                      }();
                    case "Rectangular":
                    return A2(Dict.member,
                      _v81,
                      grid._1);}
                 _E.Case($moduleName,
                 "between lines 87 and 94");
              }();}
         _E.Case($moduleName,
         "between lines 87 and 94");
      }();
   });
   var valueAt = F2(function (coord,
   grid) {
      return function () {
         switch (grid.ctor)
         {case "Hexagonal":
            return A2(Dict.lookup,
              coord,
              grid._1);
            case "Rectangular":
            return A2(Dict.lookup,
              coord,
              grid._1);}
         _E.Case($moduleName,
         "between lines 98 and 100");
      }();
   });
   var remove = F2(function (coord,
   grid) {
      return function () {
         switch (grid.ctor)
         {case "Hexagonal":
            return Hexagonal(grid._0)(A2(Dict.remove,
              coord,
              grid._1));
            case "Rectangular":
            return Rectangular(grid._0)(A2(Dict.remove,
              coord,
              grid._1));}
         _E.Case($moduleName,
         "between lines 104 and 108");
      }();
   });
   var insert = F3(function (coord,
   v,
   grid) {
      return Basics.not(A2(inGrid,
      coord,
      grid)) ? Maybe.Nothing : function () {
         switch (grid.ctor)
         {case "Hexagonal":
            return Maybe.Just(Hexagonal(grid._0)(A3(Dict.insert,
              coord,
              v,
              grid._1)));
            case "Rectangular":
            return Maybe.Just(Rectangular(grid._0)(A3(Dict.insert,
              coord,
              v,
              grid._1)));}
         _E.Case($moduleName,
         "between lines 196 and 201");
      }();
   });
   var insertIfPossible = F3(function (coord,
   v,
   grid) {
      return Basics.not(A2(inGrid,
      coord,
      grid)) ? grid : A2(Maybe.maybe,
      grid,
      Basics.id)(A3(insert,
      coord,
      v,
      grid));
   });
   var gridEqual = F2(function (grid1,
   grid2) {
      return function () {
         switch (grid1.ctor)
         {case "Hexagonal":
            return function () {
                 switch (grid2.ctor)
                 {case "Hexagonal":
                    return !_U.eq(grid1._0,
                      grid2._0) ? false : !_U.eq(Dict.toList(grid1._1),
                      Dict.toList(grid2._1)) ? false : true;}
                 return false;
              }();
            case "Rectangular":
            return function () {
                 switch (grid2.ctor)
                 {case "Rectangular":
                    return !_U.eq(grid1._0,
                      grid2._0) ? false : !_U.eq(Dict.toList(grid1._1),
                      Dict.toList(grid2._1)) ? false : true;}
                 return false;
              }();}
         _E.Case($moduleName,
         "between lines 208 and 220");
      }();
   });
   _elm.HexGrid.values = {_op: _op
                         ,hexCoord: hexCoord
                         ,rectangularHexGrid: rectangularHexGrid
                         ,hexagonalHexGrid: hexagonalHexGrid
                         ,showHexGrid: showHexGrid
                         ,pixelToHexCoord: pixelToHexCoord
                         ,inGrid: inGrid
                         ,valueAt: valueAt
                         ,remove: remove
                         ,neighbors: neighbors
                         ,diagonals: diagonals
                         ,distance: distance
                         ,axialToCube: axialToCube
                         ,line: line
                         ,hexMult: hexMult
                         ,hexAdd: hexAdd
                         ,range: range
                         ,rotation: rotation
                         ,ring: ring
                         ,neighbor: neighbor
                         ,hexRound: hexRound
                         ,insert: insert
                         ,insertIfPossible: insertIfPossible
                         ,gridEqual: gridEqual
                         ,Rectangular: Rectangular
                         ,Hexagonal: Hexagonal
                         ,Left: Left
                         ,Right: Right
                         ,SColor: SColor
                         ,STextured: STextured
                         ,SGradient: SGradient
                         ,SOutlined: SOutlined};
   return _elm.HexGrid.values;
};</script></head><body><script type="text/javascript">Elm.fullscreen(Elm.Atsumari)</script><noscript></noscript></body></html>